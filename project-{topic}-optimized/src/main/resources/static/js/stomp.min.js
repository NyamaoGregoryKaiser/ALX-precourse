```javascript
/*
 * stomp.js version 2.3.3
 *
 * This file is part of the stomp-websocket project, a STOMP over WebSocket client.
 *
 * Copyright (C) 2010-2016 [Jeff Mesnil](http://jmesnil.net/)
 * Copyright (C) 2012 [Pearce Farwell](http://www.pearcefarwell.com)
 * Copyright (C) 2013-2016 [Apollo Team](http://activemq.apache.org/apollo)
 * Copyright (C) 2015-2016 [Juergen Brendel](https://github.com/jmesnil/stomp-websocket)
 *
 * This project was originally created by Jeff Mesnil in 2010.
 *
 * It has been forked by the Apollo Team and refactored by [Olivier Dejean](http://odejean.info)
 * to support both STOMP 1.0, 1.1 and 1.2.
 *
 * This project uses the Apache 2.0 license.
 */
var Stomp;

(function() {
  var Host,
    Client,
    Frame,
    NullLayer,
    client,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }

      function Ctor() {
        this.constructor = child;
      }
      Ctor.prototype = parent.prototype;
      child.prototype = new Ctor();
      child.__super__ = parent.prototype;
      return child;
    },
    __slice = [].slice;

  Host = (function() {
    function Host(url) {
      var parts;
      parts = url.split(":");
      this.protocol = parts[0];
      this.virtualHost = parts[1] || "/";
      this.hostname = parts[2];
      this.port = parts[3];
      this.path = parts[4] || "/";
    }

    return Host;
  })();

  Frame = (function() {
    var LF;

    LF = '\n';

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function() {
      var lines, name, skipContentLength, value, _ref;
      lines = [this.command];
      skipContentLength = this.headers['content-length'] === false;
      if (skipContentLength) {
        delete this.headers['content-length'];
      }
      _ref = this.headers;
      for (name in _ref) {
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body && !skipContentLength) {
        lines.push("content-length:" + (Frame.sizeOfUTF8(this.body)));
      }
      lines.push(LF);
      lines.push(this.body);
      return lines.join(LF);
    };

    Frame.sizeOfUTF8 = function(s) {
      if (s) {
        return encodeURI(s).match(/%..|./g).length;
      } else {
        return 0;
      }
    };

    Frame.unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, line, start, trim, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      divider = data.search(RegExp("" + LF + LF));
      headerLines = data.substring(0, divider).split(LF);
      command = headerLines.shift();
      headers = {};
      _ref = headerLines.reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        idx = line.indexOf(':');
        headers[line.substring(0, idx)] = line.substring(idx + 1);
      }
      trim = headers['content-length'] != null ? 0 : 1;
      start = divider + (2 * LF.length);
      body = data.substring(start);
      if (headers['content-length'] != null) {
        _ref1 = headers['content-length'];
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          chr = _ref1[i];
          if ((_ref2 = data.charCodeAt(start + i)) !== 0 && _ref2 !== 10 && _ref2 !== 13) {
            break;
          }
          start++;
        }
        trim = body.length - headers['content-length'];
      }
      if (trim) {
        _ref3 = body.slice(-trim);
        for (i = 0, _len = _ref3.length; i < _len; i++) {
          chr = _ref3[i];
          if (chr !== LF && chr !== '\0') {
            trim = 0;
            break;
          }
        }
      }
      body = body.substring(0, body.length - trim);
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var data;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp("" + '\0' + LF + "*"));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) > 0) {
            _results.push(Frame.unmarshallSingle(data));
          }
        }
        return _results;
      })();
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + '\0';
    };

    return Frame;

  })();

  NullLayer = (function() {
    function NullLayer() {}

    NullLayer.prototype.send = function() {};

    return NullLayer;

  })();

  Client = (function() {
    var VERSIONS, add10xCallback, add11xCallback, addCommonCallback;

    VERSIONS = {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function() {
        return "1.0,1.1,1.2";
      }
    };

    addCommonCallback = function(name, header) {
      var onreceive;
      onreceive = header;
      if (typeof onreceive !== 'function') {
        onreceive = function(frame) {
          return header[name](frame);
        };
      }
      return this.onreceive[header] = onreceive;
    };

    add10xCallback = function(name, header) {
      var onreceive;
      onreceive = header;
      if (typeof onreceive !== 'function') {
        onreceive = function(frame) {
          return header[name](frame.headers['message-id'], frame.headers.destination, frame.body, frame.headers);
        };
      }
      return this.onreceive[header] = onreceive;
    };

    add11xCallback = function(name, header) {
      var onreceive;
      onreceive = header;
      if (typeof onreceive !== 'function') {
        onreceive = function(frame) {
          return header[name](frame.headers['message-id'], frame.headers.destination, frame.body, frame.headers);
        };
      }
      return this.onreceive[header] = onreceive;
    };

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.maxWebSocketFrameSize = 16 * 1024;
      this.subscriptions = {};
      this.partialBuffer = '';
    }

    Client.prototype.debug = function(message) {
      var _ref;
      if (typeof window !== 'undefined' && window.console && window.console.log) {
        return window.console.log((_ref = this.ws) != null ? _ref.url : void 0, message);
      }
    };

    Client.prototype._transmit = function(command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      while (true) {
        if (out.length > this.maxWebSocketFrameSize) {
          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
          out = out.substring(this.maxWebSocketFrameSize);
          if (typeof this.debug === "function") {
            this.debug(">>> send partial message " + out.length);
          }
        } else {
          this.ws.send(out);
          return;
        }
      }
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, _ref, _ref1,
        _this = this;
      if ((_ref = headers.version) !== VERSIONS.V1_1 && _ref !== VERSIONS.V1_2) {
        return;
      }
      _ref1 = headers['heart-beat'].split(",").map(function(v) {
        return parseInt(v);
      }), serverIncoming = _ref1[0], serverOutgoing = _ref1[1];
      if (this.heartbeat.outgoing !== 0 && serverOutgoing !== 0) {
        this.pinger = setInterval(function() {
          _this.ws.send(LF);
          return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
        }, Math.max(_this.heartbeat.outgoing, serverOutgoing));
      }
      if (this.heartbeat.incoming !== 0 && serverIncoming !== 0) {
        return this.ponger = setInterval(function() {
          var delta;
          delta = Date.now() - _this.lastServerActivity;
          if (delta > Math.max(_this.heartbeat.incoming, serverIncoming)) {
            if (typeof _this.debug === "function") {
              _this.debug("!!! STOMP: server did not send a heartbeat for " + delta + "ms, disconnecting");
            }
            return _this.ws.close();
          }
        }, Math.max(this.heartbeat.incoming, serverIncoming));
      }
    };

    Client.prototype._parseConnect = function() {
      var args, connectCallback, errorCallback, headers;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      headers = {};
      switch (args.length) {
        case 2:
          connectCallback = args[0];
          errorCallback = args[1];
          break;
        case 3:
          headers.login = args[0];
          headers.passcode = args[1];
          connectCallback = args[2];
          errorCallback = null;
          break;
        case 4:
          headers.login = args[0];
          headers.passcode = args[1];
          connectCallback = args[2];
          errorCallback = args[3];
          break;
        default:
          headers = args[0];
          connectCallback = args[1];
          errorCallback = args[2];
      }
      return [headers, connectCallback, errorCallback];
    };

    Client.prototype.connect = function() {
      var args, client, connectCallback, errorCallback, headers, _ref,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = this._parseConnect.apply(this, args), headers = _ref[0], connectCallback = _ref[1], errorCallback = _ref[2];
      headers['accept-version'] = VERSIONS.supportedVersions();
      headers['heart-beat'] = [this.heartbeat.outgoing, this.heartbeat.incoming].join(',');
      this.ws.onopen = function() {
        if (typeof _this.debug === "function") {
          _this.debug('WebSockets Open!');
        }
        return _this._transmit("CONNECT", headers);
      };
      this.ws.onmessage = function(evt) {
        var frame, message, _i, _len, _ref1;
        if (typeof _this.debug === "function") {
          _this.debug('<<< ' + evt.data);
        }
        _this.lastServerActivity = Date.now();
        if (evt.data === LF) {
          return;
        }
        _this.partialBuffer += evt.data;
        _ref1 = Frame.unmarshall(_this.partialBuffer);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          frame = _ref1[_i];
          _this.partialBuffer = '';
          if (frame.command === "CONNECTED") {
            if (typeof _this.debug === "function") {
              _this.debug("connected to STOMP version " + frame.headers.version);
            }
            _this.connected = true;
            _this.version = frame.headers.version;
            _this._setupHeartbeat(frame.headers);
            return typeof connectCallback === "function" ? connectCallback(frame) : void 0;
          } else if (frame.command === "MESSAGE") {
            _this.onreceive(frame.headers.destination, frame);
            if (frame.headers.ack !== 'auto') {
              return _this._transmit("ACK", {
                'message-id': frame.headers['message-id'],
                'subscription': frame.headers.subscription
              });
            }
          } else if (frame.command === "RECEIPT") {
            return _this.onreceipt(frame.headers['receipt-id'], frame);
          } else if (frame.command === "ERROR") {
            return typeof errorCallback === "function" ? errorCallback(frame) : void 0;
          } else {
            return typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0;
          }
        }
      };
      this.ws.onclose = function() {
        var msg;
        msg = "Whoops! Lost connection to " + _this.ws.url;
        if (typeof _this.debug === "function") {
          _this.debug(msg);
        }
        _this.connected = false;
        if (_this.pinger) {
          clearInterval(_this.pinger);
        }
        if (_this.ponger) {
          clearInterval(_this.ponger);
        }
        return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
      };
      return this.ws.onerror = function(evt) {
        return typeof errorCallback === "function" ? errorCallback(evt) : void 0;
      };
    };

    Client.prototype.disconnect = function(disconnectCallback, headers) {
      var _this = this;
      if (headers == null) {
        headers = {};
      }
      this._transmit("DISCONNECT", headers);
      this.ws.onclose = null;
      this.ws.close();
      this.connected = false;
      if (this.pinger) {
        clearInterval(this.pinger);
      }
      if (this.ponger) {
        clearInterval(this.ponger);
      }
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      var client, id,
        _this = this;
      if (headers == null) {
        headers = {};
      }
      id = "sub-" + (this.counter++);
      headers.destination = destination;
      headers.id = id;
      if (headers.ack == null) {
        headers.ack = 'auto';
      }
      client = this;
      this.onreceive[id] = function(frame) {
        var onreceive;
        onreceive = client.onreceive[id];
        if (client.version === VERSIONS.V1_0) {
          return onreceive(frame.headers['message-id'], frame.headers.destination, frame.body, frame.headers);
        } else {
          return onreceive(frame);
        }
      };
      this._transmit("SUBSCRIBE", headers);
      return {
        id: id,
        unsubscribe: function() {
          return _this.unsubscribe(id);
        }
      };
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.onreceive = function(destination, frame) {
      var s, _i, _len, _ref, _results;
      _ref = this.subscriptions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (s.destination === destination) {
          _results.push(s.callback(frame));
        }
      }
      return _results;
    };

    Client.prototype.onreceipt = function(receiptId, frame) {
      return this.subscriptions[receiptId](frame);
    };

    return Client;

  })();

  Stomp = {
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp', 'v12.stomp'];
      }
      klass = WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame,
    VERSIONS: VERSIONS
  };

  if (typeof window !== 'undefined' && window.WebSocket) {
    client = Stomp.client;
  } else {
    client = Stomp.over(new NullLayer());
  }

  this.Stomp = Stomp;

}).call(this);
```